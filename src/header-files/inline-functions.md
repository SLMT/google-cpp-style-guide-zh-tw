## 行內函式 (Inline Functions)

> 只有在函式程式碼少於或等於 10 行時才將它宣告為行內函式。

### 定義

透過宣告函式為行內函式，可以讓編譯器直接在呼叫該函式的地方展開函式，而不是遵照一般的函式呼叫機制編譯。

### 優點

只要函式夠小，將函式宣告為行內函式可以產生更有效率的目的碼 (object code)。 你可以盡量將存取函式 (accessor) 、修改函式 (mutator) 以及一些極短但對效能有巨大影響的函式行內化。

### 缺點

過度使用行內函式可能會造成程式變慢。 依照函式長度的不同，行內化可能會增加或減少程式碼的大小。 行內化一個很小的存取函式通常可以減少程式碼的長度，不過行內化一個很大的函式可能會巨幅地增加長度。 現在的處理器因為指令快取 (instruction cache) 的關係，處理較短的程式碼通常會更快。

### 我們的決定

一個適當的規則是不要將 10 行以上的函式行內化。 其中要特別注意解構函式 (destructors)，解構函式常常比你所看到的還要長。 因為解構函式還會隱性地另外呼叫成員以及基底類別 (base class) 的解構函式。

另一個有用的規則： 一般來說將一個具有有迴圈或者 `switch` 的函式行內化對效能並沒有幫助 (除非大多數的情況下這個迴圈或 `switch` 都不會被執行到)。

要特別注意的是，就算將一個函式宣告為行內函式，編譯器也不一定會照做。 例如：虛擬函式 (virtual function) 或遞迴函式 (recursive function) 常常不會被行內化。 因為遞迴函式ㄧ般來說不該是行內函式。 至於將虛擬函式寫成行內函式的理由，通常只是為了要方便將函式的定義放在類別內而已 (例如類別的存取函式或修改函式)。

### 譯註

這邊提供一個行內函式的範例，`inline` 關鍵字是將函式行內化的關鍵：

```c++
inline int sum(int a, int b) {
	return a + b;
}
```
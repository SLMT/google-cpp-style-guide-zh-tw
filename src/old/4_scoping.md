
## 非成員、靜態成員、全域函式

> 盡量將非成員函式放在名稱空間中，少用完全的全域函式。 盡量用名稱空間來組織函式，而不是用類別。 類別的靜態成員一般來說應該要與類別的實例或者靜態資料有關。

### 優點

非成員及靜態成員函式在某些狀況下很有用。 將非成員函式放在名稱空間中可以避免汙染全域的名稱空間。

### 缺點

非成員及靜態成員函式也許作為某個類別中的成員會更合理，特別是這些函式會存取一些外部資源或者有高度相關時。

### 抉擇

有時候定義一個不受類別實例限制的函式很有用，甚至某些狀況下是必要的。 這樣的函式可以是非成員或者靜態成員函式。 非成員函式不應該依賴在某個外部變數上，而且應該放在某個名稱空間內。 不要特別為了一群函式建立一個沒有分享任何靜態變數的類別，如果要組織起來的話，請使用[名稱空間](#namespace)。 例如，在 `myproject/foo_bar.h` 標頭檔內，請寫：

```c++
namespace myproject {
namespace foo_bar {
void Function1();
void Function2();
}
}
```

而不要寫：

```c++
namespace myproject {
class FooBar {
 public:
  static void Function1();
  static void Function2();
};
}
```



如果你要定義一個非成員函式，而且這個函式只會用在某個 `.cc` 檔中，請利用[內部連結性](#unnamed_namespace_and_static_variables)來限制它的作用域。

## 區域變數

> 將函式的變數盡可能地放在最小的作用域內，並在宣告變數的同時初始化

C++ 允許你在函式內的任何地方宣告變數。 我們鼓勵你盡可能地將變數宣告在越局部的 (local) 作用域越好，並且最好越靠近它第一次被使用的地方。 這讓讀者會更容易找到變數的宣告處以及了解它的型別是甚麼。 特別要注意初始化與宣告不該分開，例如：

```c++
int i;
i = f();      // 不好 -- 初始化與宣告分離
```

```c++
int j = g();  // 良好 -- 宣告同時初始化
```

```c++
vector<int> v;
v.push_back(1);  // 最好使用括號初始化法 (brace initialization)
v.push_back(2);
```

```c++
vector<int> v = {1, 2};  // 良好 -- v 一開始就初始化好
```

`if`、`while` 與 `for` 陳述句需要的變數一般來說應該要被宣告並限制在所屬的作用域內，例如：

```c++
while (const char* p = strchr(str, '/')) str = p + 1;
```

有一個要注意的特例：如果該變數是物件，那該物件的建構函式每次進入這個作用域時就會被呼叫一次，解構函式也會每次離開時都會被呼叫到。

```c++
// 低效率的寫法
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // 我的建構函式與解構函式會各被呼叫 1000000 次
  f.DoSomething(i);
}
```

此時將這個變數宣告在迴圈外面，程式執行時會比較有效率：

```c++
Foo f;  // 我的建構函式與解構函式只會各被呼叫一次
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
```

## 靜態與全域變數

不允許使用有著靜態生存期 ([static storage duration](http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration)) 的物件，除非他們是可平凡解構的 ([trivially destructible](http://en.cppreference.com/w/cpp/types/is_destructible))。 白話來說，這代表他的解構函式不做任何事情，包括他的成員與基底類別的解構函式在內。 更正式地說，這代表他的型別沒有使用者定義的或是虛擬的解構函式，而且他的基底類別跟非靜態成員都是可平凡解構的。 函式內的區域變數可以使用動態初始化。 不鼓勵對靜態類別成員變數與位於命名空間作用域的變數使用動態初始化，但是在某些限定的情況下允許。 請看以下說明。

經驗法則：如果一個全域變數的宣告是 `constexpr` (常數表達式) 的話，他就符合這些要求。

### 定義

每個物件都有生存期 (storage duration)，這與他的存活期 (lifetime) 相關。 有著靜態生存期的物件從被初始化到程式結束都會存活。 這種物件出現在命名空間作用域 (全域變數)，作為類別的靜態資料成員或者函式中帶有 `static` 字樣的區域變數。 函式區域靜態變數在執行經過他的宣告時被初始化；所有其他有著靜態生存期的物件在程式啟動時初始化。 所有有著靜態生存期的物件在程式結束時被摧毀 (發生在所有尚未加入的線程終止之前)。

初始化可以是動態的，也就是說在初始化時可以發生一些不平凡 (non-trivial) 的事情。 (例如：一個會分配記憶體的建構函式，或是需要現在程序的 ID 才能初始化的變數。) 其他類的初始化都算是靜態初始化。 這兩者並不是完全相反的： 有著靜態生存期的物件**總是**會先靜態初始化 (用一個給定的常數或者全部都是零的表示法初始化變數)，然後需要的話才會動態初始化。

### 優點

全域與靜態變數對於大量的應用來說非常好用： 命名的常數、一些轉換元件中的輔助資料結構、命令提示的旗標 (flag)、日誌、註冊機制、背景基礎設施等等。

### 缺點

全域與靜態變數使用著動態初始化或者不平凡的解構函式產生的複雜度容易導致難以尋找的錯誤。 動態初始化在轉換元件之間或者解構時沒有被排序 (除了那種在反向初始化時的解構動作)。 當一個初始化指向另一個有著靜態生存期的變數時，有可能會導致一個物件在他的存活期開始前 (或者結束之後) 被存取。 更甚者，當一個程式啟動了一些在結束時還沒加入的線程，這些線程可能會存取那些已經結束存活期的物件 (如果他的解構函式已經跑完的話)。

### 抉擇

#### 解構的抉擇

當解構函式是平凡的 (trivial)，他的執行完全並不會被順序所影響 (因為他們基本上不會執行)；不然的話，我們會暴露在某些物件結束存活期之後存取他們的風險之中。 因此，我們只允許可平凡解構的物件擁有靜態生存期。 基本型別 (像是指標或者 `int`) 都是可平凡解構的，這些型別的陣列也都是。 注意被標示 `constexpr` 的變數也是可平凡解構的。

```c++
const int kNum = 10;  // 允許

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // 允許

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // 允許
}

// 允許: constexpr 保證平凡的解構函式
constexpr std::array<int, 3> kArray = {{1, 2, 3}};
```

```c++
// 不好: 非可平凡解構的
const string kFoo = "foo";

// 因為某些原因所以不好，雖然 kBar 是一個參考 (reference)。注意這個規則
// 也適用於延長存活期的暫存物件中。
const string& kBar = StrCat("a", "b", "c");

void bar() {
  // 不好: 非可平凡解構函式
  static std::map<int, int> kData = {{1, 0}, {2, 0}, {3, 0}};
}
```

注意參考並非物件，所以他們並不會被解構的限制所影響。 不過動態初始化的限制仍然適用。 特別是，一個具有 `static T& t = *new T;` 形式的函式區域靜態變數是允許的。

#### 初始化的抉擇

初始化是一個更複雜的主題。 因為我們不只要考慮類別的建構式是否執行，也要考慮初始化時的計算：

```c++
int n = 5;    // 可以
int m = f();  // ? (根據 f)
Foo x;        // ? (根據 Foo::Foo)
Bar y = g();  // ? (根據 g 與 Bar::Bar)
```

除了第一式之外都帶來不確定的初始化順序問題。



#### 常見模式


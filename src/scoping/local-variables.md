## 區域變數

> 將函式的變數盡可能地放在最小的作用域內，並在宣告變數的同時初始化。

C++ 允許你在函式內的任何地方宣告變數。 我們鼓勵你盡可能地將變數宣告在越局部的作用域越好，並且最好靠近它第一次被使用的地方。 這讓讀者更容易找到變數的宣告位置，並了解其型別及初始化值。 特別要注意初始化與宣告應避免分開，例如：

```cpp
int i;
i = f();      // 不好 -- 初始化與宣告分離
```

```cpp
int i = f();  // 很好 -- 宣告同時初始化
```

```cpp
int jobs = NumJobs();
// 很多程式碼...
f(jobs);      // 不好 -- 宣告與使用處分離
```

```cpp
int jobs = NumJobs();
f(jobs);      // 很好 -- 宣告後面緊跟著（或很接近）使用處
```

```cpp
std::vector<int> v;
v.push_back(1);  // 偏好使用大括號初始化法 (brace initialization)
v.push_back(2);
```

```cpp
std::vector<int> v = {1, 2};  // 很好 -- v 一開始就初始化好
```

`if`、`while` 與 `for` 陳述句需要的變數一般來說應宣告在該陳述句內，以將其限制在對應的作用域中。 例如：

```cpp
while (const char* p = strchr(str, '/')) str = p + 1;
```

有一個例外：如果該變數是物件，則每次進入該作用域時，建構函式都會被呼叫，而解構函式則會在離開時執行。

```cpp
// 低效率的寫法
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // 我的建構函式與解構函式會各被呼叫 1000000 次
  f.DoSomething(i);
}
```

在這種情況下，將變數宣告在迴圈外能提升執行效率：

```cpp
Foo f;  // 我的建構函式與解構函式只會各被呼叫一次
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
```

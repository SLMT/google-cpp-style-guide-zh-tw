# 標頭檔 (Header Files)

一般來說，每一個 `.cc` 檔都應該要有一個對應的 `.h` 檔。 不過也有一些常見的例外，像是單元測試 (Unit Test) 跟一些只包含著 `main()` 的小型 `.cc` 檔就不需要有。

正確地使用標頭檔可以對可讀性、程式碼大小與效能帶來巨大的影響。

以下這些原則會引領你克服標頭檔中各式各樣的陷阱。


## 自給自足標頭檔 (Self-contained Headers)

> 標頭檔應該要自給自足 (self-contained)，而且副檔名必須是 `.h`。 專門用來插入文件的檔案，則應該要使用 `.inc` 作為副檔名。 不允許使用 `-inl.h` 作為標頭檔名結尾。

所有標頭檔都應該要自給自足。 換句話說，使用者或者重構工具 (Refractoring Tool) 並不需要依賴任何額外的條件才能夠插入標頭檔。 更精確地說，標頭檔應該要包含 [`#define` 保護](#define_guard)，而且應該要自己插入所有需要的其他標頭檔，同時也不需要 `#define` 任何額外的符號才能使用。

有幾個少數的狀況下，某些檔案是用來在程式碼的特定位置中插入文件，這些檔案並不需要自給自足。 像是有些檔案會被載入多次，或者這些檔案其實是其他標頭檔中的一些對於某平台 (platform-specific) 的擴充。 這種類型的檔案就該使用 `.inc` 作為副檔名。

如果有模板或者行內函式宣告於 `.h` 檔中，那務必也要在同一個檔案內定義它們的內容。 所有使用到這些東西的 `.cc` 檔都應該要載入這些結構，不然在某些建置設定下會造成程式無法連結。 不要將這些定義移至額外的 `-inl.h` 檔中。

有一個例外是，函式模板的顯式實體化 (explicitly instantiated) 或者該模板是一個類別的私有成員的話，可以只定義在實體化該模板的 `.cc` 檔中。


## `#define` 保護 (The `#define` Guard) <a name="define_guard"></a>

> 所有的標頭檔應該要包含 `#define` 保護，以防止多重載入。 其名稱的格式為 `<專案名稱>_<路徑>_<檔名>_H_`。

為了保證名稱的獨特性，應該要遵照該檔案在專案中的完整路徑來定義。 例如，一個在專案 foo 之中 `foo/src/bar/baz.h` 位置下的檔案，其保護應該要這樣寫：

```c++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```


## 前向宣告 (Forward Declarations)

> 你可以透過前向宣告常見的類別來避免不必要的 `#include`。

### 定義

類別、函式與模板的前向宣告指的就是在沒有定義其內容的情況下，預先宣告名稱的程式碼。 無論使用者使用甚麼類型的符號，往往可以使用前向宣告來替代 `#include`。

### 優點

- 不必要的 `#include` 使得編譯器處理時必須要開啟更多檔案而且處理更多資料。
- 這些不必要的 `#include` 也有可能造成你的標頭檔有點修改，其他相關的程式碼就得需要被重新編譯。

### 缺點

- 如果牽涉到模板、`typedef`、預設參數或者 `using` 的話，就很難正確地寫出前向宣告。
- 有時候很難界定到底是否該在程式碼中使用前向宣告，或者全部使用 `#include` ，尤其是牽涉到隱式轉換 (implicit conversion) 的時候。 在某些極端的狀況下，替換掉 `#include` 可能會大幅改變程式碼的意義。
- 大量的前向宣告比起單純的一行 `#include` 會讓程式碼看起來冗長許多。
- 函式與模板的前向宣告會造成撰寫標頭檔的人無法更改 API。 舉例來說，增加函式接受的參數，或是給模板增加一個預設數值。
- 前向宣告 `std::` 名稱空間內的符號時常產生一些未定義的行為
- 為了使用前向宣告而重構程式碼（像是把把物件成員換成指標），可能會造成程式變慢或者更加複雜
- 現在也尚未證實前向宣告實際上是否可以真的帶來效益

### 抉擇

- 當你要使用一個宣告在標頭檔內的函式時，使用 `#include`
- 當你要使用類別模板時，盡量使用 `#include`
- 當你要使用一個常見的類別時，可以使用前向宣告，但是請自行辨別這樣做是否對真的有幫助。 如果不太確定的話，就使用 `#include` 吧。
- 別為了避免使用 `#include` 而把資料成員換成指標

### 譯註

老實說我也是第一次看到「前向宣告」這個詞，因此我花了點時間研究這到底是什麼東西。 我稍微閱讀了[維基百科](https://en.wikipedia.org/wiki/Forward_declaration)上的資料之後，在此寫下我對這個這個詞的理解。

事實上，前向宣告這個詞簡單來說就是「在定義之前先宣告」。 相信應該不少人有宣告過函式吧？像是：

```c++
int sum(int, int);
```

這裏你可以看到我們並沒有寫說 `sum` 這個函式代表著什麼意思，只說他接受兩個整數參數，回傳一個整數值，而實際上 `sum` 的內容則定義在別的地方。 這個目的就是在告訴編譯器：「有個叫做 `sum` 的函式存在，等下使用時，請把 `sum` 這個符號當成一個接受兩個整數參數，回傳一個整數的函式處理。」

其實這就是一個「前向宣告」，也就是預先告知這個東西的存在，然後再另外定義內容。

前向宣告除了函式之外，也可以用在類別與模板上。 假設現在其他檔案中定義了 `class A`，而你的檔案需要用到它，你可以單純地宣告：

```c++
class A;
```

這樣就可以不用使用 `#include` 來載入相關的標頭檔。 但是這個使用有個限制，就是程式碼中使用到 `class A` 的地方，都只能使用指標或參考，而不能直接使用像是 `A a` 這樣的變數。 使用類別的前向宣告要注意的事情相對比較多，所以上面的建議才會提到大部份的情況還是直接 `#include` 比較好。

## Inline Functions

TBT.

## Function Parameter Ordering

TBT.

## Names and Order of Includes

TBT.

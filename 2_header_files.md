# 標頭檔 (Header Files)

一般來說，每一個 `.cc` 檔都應該要有一個對應的 `.h` 檔。 不過也有一些常見的例外，像是單元測試 (Unit Test) 跟一些只包含著 `main()` 的小型 `.cc` 檔就不需要有。

正確地使用標頭檔可以對可讀性、程式碼大小與效能帶來巨大的影響。

以下這些原則會引領你克服標頭檔中各式各樣的陷阱。


## 自給自足標頭檔 (Self-contained Headers)

> 標頭檔應該要自給自足 (self-contained)，而且副檔名必須是 `.h`。 專門用來插入文件的檔案，則應該要使用 `.inc` 作為副檔名。 不允許使用 `-inl.h` 作為標頭檔名結尾。

所有標頭檔都應該要自給自足。 換句話說，使用者或者重構工具 (Refractoring Tool) 並不需要依賴任何額外的條件才能夠插入標頭檔。 更精確地說，標頭檔應該要包含 [`#define` 保護](#define_guard)，而且應該要自己插入所有需要的其他標頭檔，同時也不需要 `#define` 任何額外的符號才能使用。

有幾個少數的狀況下，某些檔案是用來在程式碼的特定位置中插入文件，這些檔案並不需要自給自足。 像是有些檔案會被載入多次，或者這些檔案其實是其他標頭檔中的一些對於某平台 (platform-specific) 的擴充。 這種類型的檔案就該使用 `.inc` 作為副檔名。

如果有模板或者行內函式宣告於 `.h` 檔中，那務必也要在同一個檔案內定義它們的內容。 所有使用到這些東西的 `.cc` 檔都應該要載入這些結構，不然在某些建置設定下會造成程式無法連結。 不要將這些定義移至額外的 `-inl.h` 檔中。

有一個例外是，函式模板的顯式實體化 (explicitly instantiated) 或者該模板是一個類別的私有成員的話，可以只定義在實體化該模板的 `.cc` 檔中。


## `#define` 保護 (The `#define` Guard) <a name="define_guard"></a>

> 所有的標頭檔應該要包含 `#define` 保護，以防止多重載入。 其名稱的格式為 `<專案名稱>_<路徑>_<檔名>_H_`。

為了保證名稱的獨特性，應該要遵照該檔案在專案中的完整路徑來定義。 例如，一個在專案 foo 之中 `foo/src/bar/baz.h` 位置下的檔案，其保護應該要這樣寫：

```c++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```


## 前向宣告 (Forward Declarations)

> 你可以透過前向宣告常見的類別來避免不必要的 `#include`。

### 定義

類別、函式與模板的前向宣告指的就是在沒有定義其內容的情況下，預先宣告名稱的程式碼。 無論使用者使用甚麼類型的符號，往往可以使用前向宣告來替代 `#include`。

### 優點

- 不必要的 `#include` 使得編譯器處理時必須要開啟更多檔案而且處理更多資料。
- 這些不必要的 `#include` 也有可能造成你的標頭檔有點修改，其他相關的程式碼就得需要被重新編譯。

### 缺點

- 如果牽涉到模板、`typedef`、預設參數或者 `using` 的話，就很難正確地寫出前向宣告。
- 有時候很難界定到底是否該在程式碼中使用前向宣告，或者全部使用 `#include` ，尤其是牽涉到隱式轉換 (implicit conversion) 的時候。 在某些極端的狀況下，替換掉 `#include` 可能會大幅改變程式碼的意義。
- 大量的前向宣告比起單純的一行 `#include` 會讓程式碼看起來冗長許多。
- 函式與模板的前向宣告會造成撰寫標頭檔的人無法更改 API。 舉例來說，增加函式接受的參數，或是給模板增加一個預設數值。
- 前向宣告 `std::` 名稱空間內的符號時常產生一些未定義的行為
- 為了使用前向宣告而重構程式碼（像是把把物件成員換成指標），可能會造成程式變慢或者更加複雜
- 現在也尚未證實前向宣告實際上是否可以真的帶來效益

### 抉擇

- 當你要使用一個宣告在標頭檔內的函式時，使用 `#include`
- 當你要使用類別模板時，盡量使用 `#include`
- 當你要使用一個常見的類別時，可以使用前向宣告，但是請自行辨別這樣做是否對真的有幫助。 如果不太確定的話，就使用 `#include` 吧。
- 別為了避免使用 `#include` 而把資料成員換成指標

### 譯註

老實說我也是第一次看到「前向宣告」這個詞，因此我花了點時間研究這到底是什麼東西。 我稍微閱讀了[維基百科](https://en.wikipedia.org/wiki/Forward_declaration)上的資料之後，在此寫下我對這個這個詞的理解。

事實上，前向宣告這個詞簡單來說就是「在定義之前先宣告」。 相信應該不少人有宣告過函式吧？像是：

```c++
int sum(int, int);
```

這裏你可以看到我們並沒有寫說 `sum` 這個函式代表著什麼意思，只說他接受兩個整數參數，回傳一個整數值，而實際上 `sum` 的內容則定義在別的地方。 這個目的就是在告訴編譯器：「有個叫做 `sum` 的函式存在，等下使用時，請把 `sum` 這個符號當成一個接受兩個整數參數，回傳一個整數的函式處理。」

其實這就是一個「前向宣告」，也就是預先告知這個東西的存在，然後再另外定義內容。

前向宣告除了函式之外，也可以用在類別與模板上。 假設現在其他檔案中定義了 `class A`，而你的檔案需要用到它，你可以單純地宣告：

```c++
class A;
```

這樣就可以不用使用 `#include` 來載入相關的標頭檔。 但是這個使用有個限制，就是程式碼中使用到 `class A` 的地方，都只能使用指標或參考，而不能直接使用像是 `A a` 這樣的變數。 使用類別的前向宣告要注意的事情相對比較多，所以上面的建議才會提到大部份的情況還是直接 `#include` 比較好。

## 行內函式 (Inline Functions)

> 只有在函式程式碼少於或等於 10 行時才將它宣告為行內函式

### 定義

透過宣告函式為行內函式，可以讓編譯器直接在呼叫該函式的地方展開函式，而不是遵照一般的函式呼叫機制編譯。

### 優點

將函式宣告為行內函式可以產生更有效率的目的碼 (object code)，因為行內函式比起一般的函式小很多。 你可以盡量將存取函式 (accessor) 、修改函式 (mutator) 以及一些極短但對效能有巨大影響的函式行內化。

### 缺點

過度使用行內函式可能會造成程式變慢。 依照函式長度的不同，行內化可能會增加或減少程式碼的大小。 行內化一個很小的存取函式通常可以減少程式碼的長度，不過行內化一個很大的函式可能會巨幅地增加長度。 現在的處理器因為指令快取 (instruction cache) 的關係，處理較短的程式碼通常會更快。

### 抉擇

一個適當的規則是不要將 10 行以上的函式行內化。 其中要特別注意解構函式 (destructors)，解構函式常常比你所看到的還要長。 因為解構函式還會隱性地另外呼叫成員以及基底類別 (base class) 的解構函式。

另一個有用的規則：一般來說將一個有迴圈或者 `switch` 的函式行內化對效能並沒有幫助 (除非大多數的情況下這個迴圈或 `switch` 都不會被執行到)。

要特別注意的是，就算將一個函式宣告為行內函式，編譯器也不一定會照做。 例如：虛擬函式 (virtual function) 或遞迴函式 (recursive function) 常常不會被行內化。 因為遞迴函式ㄧ般來說不該是行內函式。 至於將虛擬函式寫成行內函式的理由，通常只是為了要方便將函式的定義放在類別內而已 (例如類別的存取函式或修改函式)。

### 譯註

這邊提供一個行內函式的範例，`inline` 關鍵字是將函式行內化的關鍵：

```c++
inline int sum(int a, int b) {
	return a + b;
}
```

## Function Parameter Ordering

> 當定義函式的時候，參數先放輸入值，再放輸出值。

C/C++ 函式的參數不是輸入值就是輸出值，甚至可能都是。 輸入參數通常會是數值或者 `const` 參考，輸出或者同時具有兩種身分的參數則通常是非 `const` 的指標。 在決定函式參數的順序時，把純輸入參數放在最前面。 特別是不要單純因為一個參數是新加的，就直接把它放在最尾端。 如果它是純輸入參數的話，一樣要放在所有輸出參數之前。

你不一定要完全遵守這個規則。 那些同時扮演兩種腳色的參數 (通常是結構或者類別) 就沒有定則，只要你自己想出一個一致的規則就好。

## Names and Order of Includes

TBT.
